// Tricky Interview Questions for Sync FIFO //


** What are almost-full and almost-empty flags used for?
   They provide early warning before FIFO reaches full/empty:
	•	Prevents stalls by signaling the next stage early.
	•	Usually generated by comparing pointer difference to a threshold.

** How do you calculate FIFO occupancy?
For synchronous FIFO: count = wr_ptr - rd_ptr;

** Why can’t we just reset wr_ptr to 0 when FIFO becomes empty (Question is why we wont allow every bit to 0, once it's empty, remember MSB doesn't change when fifo is full and all data is readed then)?
Because the pointer difference (and phase bits) already encode empty/full correctly.
Manually resetting would break pointer continuity and cause incorrect flag detection.

** What if both pointers overflow their bit width?
No issue. The wrap bit toggles each time, and since flags depend on the relative difference, not absolute value, FIFO behavior repeats correctly every full wrap.

** How do simultaneous read/write affect full/empty?
If rd_en and wr_en are both asserted and FIFO not full/empty:
	•	wr_ptr and rd_ptr increment together.
	•	Occupancy remains constant.
	•	full and empty flags remain unchanged.

** How do synthesis tools infer memory for FIFO?
	•	Small FIFOs → implemented as flip-flops or distributed RAM (LUTRAM).
	•	Large FIFOs → inferred as block RAM (BRAM).

** What happens during pointer wrap-around?
When pointer reaches maximum address, next increment flips MSB (wrap bit), and address resets to 0.
This maintains continuous operation without manual resets.

** Can a FIFO have different data widths for read/write?
Not in this simple synchronous design.
For width conversion (e.g., 64-bit writes, 32-bit reads), you need a dual-port RAM or width-adapting FIFO.


** FIFO depth not power of 2 :
Answer:
Problems:
Pointer wrap logic fails
Full detection breaks
Solutions:
Use counter-based FIFO
Restrict depth to power of 2
Use explicit boundary checks

5. FULL/EMPTY Using Pointer MSB Toggle
To utilize all entries:

Pointers become wider
wptr = {wrap_bit, addr_bits}
rptr = {wrap_bit, addr_bits}

Empty condition:
empty = (wptr == rptr)

Full condition:

Full when:
->address bits equal
->wrap bits differ

full = (wptr[MSB] != rptr[MSB]) &&
       (wptr[ADDR_BITS-1:0] == rptr[ADDR_BITS-1:0]);
This is industry-standard for FPGAs and ASICs.

